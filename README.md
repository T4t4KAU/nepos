# THUæ“ä½œç³»ç»Ÿå®éªŒæ—¥å¿—

æ“ä½œç³»ç»Ÿã€ç¼–è¯‘å™¨å’Œæ•°æ®åº“ç³»ç»Ÿåœ¨è®¡ç®—æœºç•Œå¹¶ç§°ä¸‰å¤§åŸºç¡€è½¯ä»¶ï¼Œæˆ‘åœ¨å¤§äºŒå’Œå¤§ä¸‰é™†ç»­å®ç°äº†åä¸¤è€…ï¼Œä½†è¿Ÿè¿Ÿæœªèƒ½æ‹¿ä¸‹OSï¼Œå¦‚ä»Šæ¬²åœ¨è¿™ä¸ªå¯’å‡è‡ªç ”ä¸€å¥—ç®€å•çš„OSå†…æ ¸ã€‚

æ„Ÿè°¢æ¸…åå¤§å­¦å·²ç»å¼€æºäº†ä¸€å¥—è¯¦ç»†çš„æ•™ç¨‹ï¼Œè¯¥æ•™ç¨‹ä¸€æ­¥æ­¥å‘Šè¯‰è¯»è€…å¦‚ä½•ä½¿ç”¨Rustå®ç°ä¸€ä¸ªOSå†…æ ¸ï¼Œæœ¬æ–‡å°†èšç„¦äºå¯¹è¯¥æ•™ç¨‹çš„è§£è¯»å’Œæ„Ÿæ‚Ÿï¼Œä¸ºè¿™ä¸ªå¯’å‡å¢æ·»ä¸€ç•ªåˆ«æ ·çš„æµªæ¼«ğŸ˜„ã€‚

æ•™ç¨‹é¦–é¡µï¼šhttps://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html

æœ¬æ–‡ä¸­æ‰€ä½¿ç”¨çš„å¼€å‘å¹³å°ä¿¡æ¯ï¼š

```
rustc --version --verbose
rustc 1.77.0-nightly (3d0e6bed6 2023-12-21)
binary: rustc
commit-hash: 3d0e6bed600c0175628e96f1118293cf44fb97bd
commit-date: 2023-12-21
host: aarch64-apple-darwin
release: 1.77.0-nightly
LLVM version: 17.0.6
```

## CH1-åº”ç”¨ç¨‹åºä¸åŸºæœ¬æ‰§è¡Œç¯å¢ƒ

å®éªŒé“¾æ¥ï¼šhttps://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/index.html

å­¦ä¹ äº†è¿™ä¸€ç« èŠ‚ï¼Œå¯ä»¥çŸ¥é“å¦‚ä½•ä½¿ç”¨Rustå®ç°ä¸€ä¸ªåŸºäºRISC-Væ¶æ„çš„ç®€å•æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œå¹¶ä¸ºè¯¥å†…æ ¸æ”¯æŒå‡½æ•°è°ƒç”¨ã€‚ä¸€ä¸ªå†…æ ¸æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªç¨‹åºï¼Œä½†å’Œæˆ‘ä»¬é€šå¸¸å®ç°çš„åº”ç”¨ç¨‹åºæœ‰å¾ˆå¤šä¸åŒã€‚ä¸€ä¸ªåº”ç”¨ç¨‹åºä½äºæœ€ä¸Šå±‚ï¼Œè°ƒç”¨ç¼–ç¨‹è¯­è¨€æä¾›çš„æ ‡å‡†åº“æˆ–å…¶ä»–ç¬¬ä¸‰æ–¹åº“å¯¹å¤–æä¾›çš„å‡½æ•°æ¥å£ï¼Œè¿™äº›æ ‡å‡†åº“å’Œç¬¬ä¸‰æ–¹åº“æ„æˆäº†åº”ç”¨ç¨‹åºæ‰§è¡Œç¯å¢ƒçš„ä¸€éƒ¨åˆ†ã€‚ç”¨æˆ·æ€åº”ç”¨æ€»è¦ç›´æ¥æˆ–é—´æ¥çš„é€šè¿‡æ“ä½œç³»ç»Ÿå†…æ ¸æä¾›çš„ç³»ç»Ÿè°ƒç”¨æ¥å®ç°ï¼Œå› æ­¤ç³»ç»Ÿè°ƒç”¨å……å½“äº†ç”¨æˆ·å’Œå†…æ ¸ä¹‹é—´çš„æ¡¥æ¢ã€‚

ç¡¬ä»¶ä¹‹ä¸Šçš†æ˜¯è½¯ä»¶ï¼Œä¸¤è€…çº¦å®šäº†ä¸€å¥—æŒ‡ä»¤é›†ä½“ç³»ç»“æ„(ISA)ï¼Œè½¯ä»¶å¯ä»¥é€šè¿‡ISAä¸­æä¾›äº†æœºå™¨æŒ‡ä»¤æ¥è®¿é—®å„ç§ç¡¬ä»¶èµ„æºã€‚äº‹å®ä¸Šï¼Œå‡½æ•°åº“å’Œæ“ä½œç³»ç»Ÿå†…æ ¸éƒ½æ˜¯å¯¹ä¸‹å±‚èµ„æºè¿›è¡Œäº†æŠ½è±¡ï¼Œå¦‚æœå‡½æ•°åº“å’Œç³»ç»Ÿå†…æ ¸éƒ½ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆå°±è¦ä½¿ç”¨æ±‡ç¼–ä»£ç ç›´æ¥æ§åˆ¶ç¡¬ä»¶ï¼Œçµæ´»æ€§é«˜ä½†æ˜¯æŠ½è±¡èƒ½åŠ›ä½ã€‚

ä¸€ä¸ªå†…æ ¸å®é™…ä¸Šæ˜¯ä¸€ä¸ªç›´æ¥åœ¨è£¸æœºä¸Šè¿è¡Œçš„ç¨‹åºï¼Œè€Œä¸ä¾èµ–å…¶ä»–çš„æ“ä½œç³»ç»Ÿã€‚æˆ‘ä»¬è¦åšçš„ç¬¬ä¸€ä»¶äº‹ï¼Œå°±æ˜¯ä¸ºåº”ç”¨ç¨‹åºç§»é™¤å¯¹æ ‡å‡†åº“çš„ä¾èµ–å’Œ `main` å‡½æ•°ï¼Œä½¿å¾—ç¨‹åºå¯ä»¥ç›´æ¥åœ¨è£¸æœºä¸Šè¿è¡Œï¼Œåªè¦åœ¨ä»£ç æ–‡ä»¶çš„å¼€å¤´åŠ ä¸Š:

```rust
#![no_std]
#![no_main]
```

è¿™æ˜¯åœ¨å‘Šè¯‰ç¼–è¯‘å™¨ä¸ä½¿ç”¨æ ‡å‡†åº“ï¼Œè€Œä½¿ç”¨ `core` åº“ï¼Œè¯¥åº“å¹¶ä¸ä¾èµ–æ“ä½œç³»ç»Ÿçš„æ”¯æŒï¼Œå…‰è¿™æ ·è¿˜ä¸å¤Ÿï¼Œè¿˜è¦å®ç°ä¸€ä¸ªpanicçš„å¤„ç†å‡½æ•°ï¼Œæ‰“å°é”™è¯¯ä¿¡æ¯ï¼Œå¹¶ç»“æŸå½“å‰ç¨‹åºã€‚

```rust
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

`core::panic::PanicInfo` æ˜¯coreåº“ä¸­çš„ä¸€ä¸ªç»“æ„ä½“ï¼Œä¿å­˜äº†panicé”™è¯¯ä¿¡æ¯ã€‚ç§»é™¤ `main` å‡½æ•°æ˜¯ä¸ºäº†ä½¿ç”¨è‡ªå®šä¹‰çš„å…¥å£ç‚¹å‡½æ•°æ¥ä»£æ›¿ï¼Œæ¥æ‰‹ç¼–è¯‘å™¨è´Ÿè´£çš„åˆå§‹åŒ–å·¥ä½œã€‚

ç¼–è¯‘å¥½çš„å†…æ ¸ä¸ä¼šæ‹¿åˆ°ä¸€å°çœŸçš„è£¸æœºä¸Šè¿è¡Œï¼Œè€Œæ˜¯ä½¿ç”¨QEMUæ¨¡æ‹Ÿä¸€å°è®¡ç®—æœºï¼Œè¿™å°è®¡ç®—æœºåŒ…å«CPUã€ç‰©ç†å†…å­˜ä»¥åŠè‹¥å¹²IOå¤–è®¾ã€‚è€Œä¸Šè¿°çš„ä¸€ç³»åˆ—æ“ä½œéƒ½æ˜¯ä¸ºäº†èƒ½è®©ç¨‹åºç¼–è¯‘åˆ°RV64GCå¹³å°ä¸Šï¼Œç¨‹åºç¼–è¯‘å®Œæˆåå°±å¯ä»¥æ”¾åˆ°QEMUæ¨¡æ‹Ÿå™¨ä¸Šè¿›è¡Œè¿è¡Œã€‚QEMUæ¨¡æ‹Ÿçš„ç¡¬ä»¶å¹³å°ä¸Šï¼Œç‰©ç†å†…å­˜çš„èµ·å§‹ç‰©ç†åœ°å€ä¸º `0x80000000`ï¼Œç‰©ç†å†…å­˜çš„é»˜è®¤å¤§å°ä¸º128MBã€‚

ç¼–å†™å¯åŠ¨æŒ‡ä»¤ï¼Œå’ŒQEMUå¯¹æ¥ï¼Œè®¾ç½®æ ˆç©ºé—´ï¼Œå¹¶è·³è½¬åˆ°ç¨‹åºå…¥å£ç‚¹ï¼š

```assembly
    .section .text.entry
    .globl _start
_start:
    la sp, boot_stack_top # è®¾ç½®æ ˆé¡¶
    call _main 

    .section .bss.stack
    .globl boot_stack_lower_bound # æ ˆçš„ä¸‹é™
   
boot_stack_lower_bound:
    .space 4096 * 16
    .globl boot_stack_top
boot_stack_top:
```

ä¸Šè¿°ä»£ç å³æ˜¯å†…æ ¸çš„å…¥å£ç‚¹ï¼Œè¦åµŒå…¥è¿™æ®µæ±‡ç¼–ï¼Œéœ€è¦åœ¨ rust ä»£ç ä¸­åŠ ä¸Šå¦‚ä¸‹è¿™æ®µæŒ‡ä»¤ï¼š

```rust
global_asm!(include_str!("entry.asm"));
```

å¹¶ä¸”è¦é¢å¤–è‡ªå®šä¹‰ä¸€ä¸ªé“¾æ¥è„šæœ¬ï¼Œä»¥è°ƒæ•´å†…æ ¸çš„å†…å­˜å¸ƒå±€ï¼Œåˆ’åˆ†äº†æ®µç©ºé—´å¹¶èµ‹äºˆåç§°ï¼š

```assembly
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000;

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    . = ALIGN(4K);
    erodata = .;
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    . = ALIGN(4K);
    edata = .;
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }

    . = ALIGN(4K);
    ebss = .;
    ekernel = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
```

è¿™æ®µé“¾æ¥è„šæœ¬æ§åˆ¶é“¾æ¥å™¨ç»„ç»‡å’Œå¸ƒå±€ç¨‹åºå„ä¸ªéƒ¨åˆ†ï¼Œè§„å®šäº†ç¨‹åºçš„åŸºåœ°å€ã€å†…æ ¸æ®µèµ·å§‹ä½ç½®ã€ä»£ç æ®µçš„èµ·å§‹ä½ç½®ç­‰å†…å­˜åˆ†å¸ƒä¿¡æ¯ï¼Œè¿™äº›æ®µå¯ä»¥ä¼šåœ¨ç¨‹åºä¸­è¢«è®¿é—®åˆ°ã€‚

ç¼–è¯‘åçš„æ–‡ä»¶è¿˜ä¸èƒ½ç›´æ¥æäº¤ç»™QEMUï¼Œè¯¥æ–‡ä»¶ä¸­è¿˜ä¿ç•™äº†ä¸€äº›å…ƒæ•°æ®ï¼Œå¿…é¡»å°†è¯¥å…ƒæ•°æ®ç§»é™¤ï¼Œæ‰èƒ½ä»QEMUå¯åŠ¨ã€‚æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤ï¼Œä½¿ç”¨QEMUå¯åŠ¨å†…æ ¸ï¼š

```
# run.sh

cargo build --release # ç¼–è¯‘
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/nepos -O binary build/os.bin # ç§»é™¤å…ƒæ•°æ®
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ./boot/boot.bin \
    -device loader,file=build/os.bin,addr=0x80200000 # æ¨¡æ‹Ÿå¯åŠ¨
```

QEMUå¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œä¼šå°†ä¸¤ä¸ªæ–‡ä»¶åŠ è½½åˆ°ç‰©ç†å†…å­˜ä¸­ï¼Œå°†  `boot.bin` åŠ è½½åˆ°ç‰©ç†å†…å­˜çš„ `0x80000000` å¼€å¤´ä¸Šçš„åŒºåŸŸä¸Šï¼Œå³ bootloader ç¨‹åºï¼ŒåŒæ—¶å°†å†…æ ¸é•œåƒåŠ è½½åˆ°ç‰©ç†åœ°å€ `0x80200000 ` ä¸Šã€‚QEMUå¯åŠ¨ä¹‹åï¼Œå†ç»è¿‡ä¸€äº›åˆå§‹åŒ–æµç¨‹åï¼Œä¼šè·³åˆ° bootloader ä¸Šæ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œ `boot.bin` ï¼Œä¹‹åè·³åˆ° os.bin æ‰§è¡Œå†…æ ¸é•œåƒçš„å¯åŠ¨ä»£ç ï¼Œæ­¤æ—¶å†…æ ¸å°±å®Œå…¨æ¥è¿‡è®¡ç®—æœºçš„æ§åˆ¶æƒäº†ã€‚

è¦è®©å†…æ ¸æ”¯æŒå‡½æ•°è°ƒç”¨ï¼Œé‚£ä¹ˆå°±è¦åˆ©ç”¨æ ˆã€‚åœ¨å¯åŠ¨ä»£ç ä¸­ï¼Œä½¿ç”¨æ±‡ç¼–ä»£ç åœ¨BSSæ®µæ€»å…±åˆ†é…äº†64KBçš„æ ˆç©ºé—´ï¼Œå¹¶åœ¨ç¨‹åºè¿›å…¥Rustå…¥å£å‰å°†æ ˆæŒ‡é’ˆè®¾ç½®æˆäº†æ ˆé¡¶çš„ä½ç½®ã€‚

äºæ˜¯ï¼Œåœ¨å†…æ ¸åˆå§‹åŒ–æ—¶ï¼Œè¦æ¸…ç†BSSæ®µç©ºé—´ï¼š

```rust
pub fn clear_bss() {
    extern "C" {
        fn sbss();
        fn ebss();
    }

    // éå†BSSæ®µ åˆå§‹åŒ–ä¸º0
    (sbss as usize..ebss as usize).for_each(|a| unsafe { 
        (a as *mut u8).write_volatile(0) 
    });
}

```

è°ƒç”¨ `sbss()` å’Œ `ebass()` å¯ä»¥ä»é“¾æ¥å™¨æ‹¿åˆ°æ®µçš„èµ·å§‹åœ°å€ï¼Œç„¶åéå†è¿™æ®µåœ°å€ï¼Œå°†0å†™å…¥åœ°å€ç©ºé—´ï¼Œå°†è¯¥ç©ºé—´æ¸…é›¶ï¼Œä¸ºå‡½æ•°è°ƒç”¨åšé“ºå«ã€‚é‚£ä¹ˆåˆ°æ­¤ä¸ºæ­¢ï¼Œå°±æˆåŠŸå®ç°äº†ä¸€ä¸ªå¯ä»¥åœ¨è£¸æœºä¸Šè¿è¡Œçš„ç¨‹åºã€‚å¯ä»¥ä½¿ç”¨RustSBIå®ç°å‘å±å¹•ä¸Šæ‰“å°å­—ç¬¦ï¼ŒSBIä¼šå¤„ç†å†…æ ¸çš„è¯·æ±‚ï¼Œå‘å†…æ ¸æä¾›æœåŠ¡ã€‚

å®ç°å¦‚ä¸‹ï¼š

```rust
/// use sbi call to putchar in console (qemu uart handler)
pub fn console_putchar(c: usize) {
    #[allow(deprecated)]
    sbi_rt::legacy::console_putchar(c);
}
```

é‚£ä¹ˆè‡ªæ­¤ä¹‹åï¼Œç¨‹åºå°±å¯ä»¥ç›´æ¥åœ¨è£¸æœºä¸Šå¹¶æ‰“å°å­—ç¬¦ã€‚

ç”±æ­¤å¯è§ï¼Œå¦‚æœæˆ‘ä»¬è¦ç¼–å†™ä¸€ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œé‚£å¿…ç„¶è¦æ¡æœ‰å¾ˆé«˜çš„è‡ªä¸»æƒã€‚æˆ‘ä»¬è¦èƒ½è‡ªå·±æ§åˆ¶å†…å­˜çš„åˆ’åˆ†å’Œå¸ƒå±€ï¼Œæ§åˆ¶ç¨‹åºçš„åœ¨è£¸æœºä¸Šçš„æ‰§è¡Œã€‚

## CH2-æ‰¹å¤„ç†ç³»ç»Ÿ

åœ¨è¿™ä¸€ç« èŠ‚ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½å®ç°ä¸€ä¸ªæ‰¹å¤„ç†ç³»ç»Ÿï¼Œç”¨æˆ·èƒ½å¤Ÿæäº¤è‡ªå·±çš„ç¨‹åºç»™ç³»ç»Ÿé€ä¸ªè¿è¡Œï¼Œç³»ç»Ÿå¯ä»¥è‡ªåŠ¨åœ°æ‰§è¡Œç”¨æˆ·æäº¤çš„ç¨‹åºï¼Œå’Œç”¨æˆ·ä¸å‘ç”Ÿäº¤äº’æˆ–åªå‘ç”Ÿå¾ˆå°‘çš„äº¤äº’ã€‚

åœ¨ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªç¨‹åºçš„æ‰§è¡Œé”™è¯¯å¯¼è‡´å…¶ä»–ç¨‹åºæˆ–è€…æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿéƒ½æ— æ³•è¿è¡Œï¼Œç³»ç»Ÿè¦èƒ½å¤Ÿç»ˆæ­¢å‡ºé”™çš„ç¨‹åºï¼Œè½¬è€Œè¿è¡Œä¸‹ä¸€ä¸ªåº”ç”¨ç¨‹åºã€‚æ“ä½œç³»ç»Ÿå¼•å…¥ç‰¹æƒçº§æœºåˆ¶ä¿æŠ¤ç³»ç»Ÿä¸è¢«å‡ºé”™ç¨‹åºç ´åï¼Œè®©åº”ç”¨ç¨‹åºè¿è¡Œåœ¨ä¸€ä¸ªå—é™çš„æ‰§è¡Œç¯å¢ƒä¸­ï¼Œæ“ä½œç³»ç»Ÿåˆ™è¿è¡Œåœ¨ä¸€ä¸ªç¡¬ä»¶ä¿æŠ¤çš„ç¯å¢ƒä¸­ï¼Œä¸ä¼šæ”¶åˆ°åº”ç”¨ç¨‹åºç ´åã€‚è¿™å°±æ˜¯æˆ‘ä»¬ç†ŸçŸ¥çš„ä¸€ä¸ªè¯´æ³•ï¼šåº”ç”¨ç¨‹åºè¿è¡Œåœ¨ç”¨æˆ·æ€ï¼Œæ“ä½œç³»ç»Ÿè¿è¡Œåœ¨å†…æ ¸æ€ã€‚

å…·ä½“è€Œè¨€ï¼Œç³»ç»Ÿç»™äºˆç”¨æˆ·æ€ç¨‹åºçš„ç¬¬ä¸€ä¸ªé™åˆ¶å°±æ˜¯ï¼Œä¸å…è®¸ç”¨æˆ·æ€ç¨‹åºæ‰§è¡Œä¸€äº›ç‰¹å®šçš„æŒ‡ä»¤ï¼Œè€Œè¿™äº›æŒ‡ä»¤åªèƒ½åœ¨å†…æ ¸æ€æ‰§è¡Œï¼Œå¯ç§°ä¹‹ä¸ºå†…æ ¸æ€ç‰¹æƒæŒ‡ä»¤é›†ã€‚å¦‚æœï¼Œç”¨æˆ·æ€ç¨‹åºæƒ³è¦é™·å…¥å†…æ ¸æ€ï¼Œé‚£ä¹ˆå¿…ç„¶æ˜¯å‘ç”Ÿäº†ä¸¤ç§æƒ…å†µï¼šæ‰§è¡ŒæŸäº›éœ€è¦ç‰¹æƒçš„åŠŸèƒ½å’Œç¨‹åºå‘ç”Ÿäº†é”™è¯¯ã€‚

å¦‚æœåº”ç”¨ç¨‹åºæƒ³è¦æ‰§è¡Œä¸€äº›å†…æ ¸æ€çš„ç‰¹æƒåŠŸèƒ½ï¼Œé‚£å°±è¦é€šè¿‡ç³»ç»Ÿè°ƒç”¨(syscall)ï¼Œç¨‹åºä½¿ç”¨ç³»ç»Ÿè°ƒç”¨åå°±å¯ä»¥é™·å…¥å†…æ ¸æ€ï¼Œæ‹¥æœ‰æ›´é«˜çš„ç‰¹æƒã€‚

å½“åº”ç”¨ç¨‹åºå¤„äºç”¨æˆ·æ€æ—¶ï¼Œå¯é€šè¿‡å¦‚ä¸‹ä»£ç å‘èµ·ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
// å‘èµ·ç³»ç»Ÿè°ƒç”¨
// x10 ä¿å­˜ç³»ç»Ÿè°ƒç”¨è¿”å›å€¼
// x11 ~ x16 ä¿å­˜ç³»ç»Ÿè°ƒç”¨å‚æ•°
// x17 ä¿å­˜ç³»ç»Ÿè°ƒç”¨ID
fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret, // è¿”å›å€¼ä¿å­˜åœ¨x10
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```

å®é™…ä¸Šå°±æ˜¯è®©ç¨‹åºè°ƒç”¨ `ecall` æŒ‡ä»¤ï¼Œå¹¶å°†å‚æ•°å­˜å…¥å¯„å­˜å™¨ï¼Œå¹¶ä¹‹åå°†è¿”å›å€¼å­˜åˆ°å¯„å­˜å™¨ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œ`call` ä¸€ç±»çš„æŒ‡ä»¤æ˜¯è·³è½¬æŒ‡ä»¤ï¼Œä¿®æ”¹ç¨‹åºè®¡æ•°å™¨ï¼Œè®©ç¨‹åºè·³è½¬åˆ°æŒ‡å®šçš„åœ°å€å¼€å§‹è¿è¡Œã€‚

åŒæ ·çš„ï¼Œå†…æ ¸è¦å®ç°å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™é‡Œå®ç°äº† `write` ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {
    match fd {
        FD_STDOUT => { // æ ‡å‡†è¾“å‡º
            let slice = unsafe { core::slice::from_raw_parts(buf,len) };
            let str = core::str::from_utf8(slice).unwrap();
            print!("{:?}", str);
            len as isize
        }
        _ => {
            panic!("unsupported fd in sys_write");
        }
    }
}
```

ç›®å‰åªæ”¯æŒå†™å…¥åˆ°æ ‡å‡†è¾“å‡ºï¼Œæ–‡ä»¶æè¿°ç¬¦è¢«é™åˆ¶ä¸ºæ ‡å‡†è¾“å‡ºã€‚

å†…æ ¸å¤„ç†ç³»ç»Ÿè°ƒç”¨ï¼š

```rust
pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize {
    match syscall_id {
        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),
        SYSCALL_EXIT => sys_exit(args[0] as i32),
        _ => panic!("Unsupported syscall_id: {}", syscall_id),
    }
}
```

æ¶‰åŠåˆ°å‡½æ•°è°ƒç”¨ï¼Œé‚£ä¹ˆå°±éœ€è¦ä½¿ç”¨åˆ°æ ˆï¼Œåœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¸‹ï¼Œæ ˆæ˜¯ä¸åŒçš„ï¼Œå¯ä»¥åˆ’åˆ†ä¸ºå†…æ ¸æ ˆå’Œç”¨æˆ·æ ˆã€‚

```rust
#[repr(align(4096))]
struct KernelStack {
    data: [u8; KERNEL_STACK_SIZE],
}

#[repr(align(4096))]
struct UserStack {
    data: [u8; USER_STACK_SIZE],
}
```

ç”¨æˆ·æ€ç¨‹åºè°ƒç”¨ `ecall` æŒ‡ä»¤åå°±è¦é™·å…¥å†…æ ¸æ€ï¼Œé‚£å°±è¦ä¿å­˜ç¨‹åºåŸæ¥çš„ä¸Šä¸‹æ–‡ï¼Œæ–¹ä¾¿åç»­æ¢å¤ç°åœºï¼Œå½“ç³»ç»Ÿè°ƒç”¨ç»“æŸåï¼Œåˆ™è¿”å›åˆ°åŸæ¥çš„åº”ç”¨ç¨‹åºä¸­ç»§ç»­æ‰§è¡Œã€‚äºæ˜¯å®ç°trapä¸Šä¸‹æ–‡ï¼š

```rust
// ä¸Šä¸‹æ–‡
#[repr(C)]
pub struct TrapContext {
    pub x: [usize; 32],
    pub sstatus: Sstatus, // æ§åˆ¶çŠ¶æ€å¯„å­˜å™¨
    pub sepc: usize, // å¼‚å¸¸æ—¶ è®°å½•æœ€åä¸€æ¡æŒ‡ä»¤åœ°å€
}
```

è‡ªæ­¤ï¼Œä¹Ÿæ´æ‚‰äº†åº”ç”¨ç¨‹åºè¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„æµç¨‹ï¼š

1. è°ƒç”¨  `ecall` æŒ‡ä»¤ï¼Œå¼€å§‹ç³»ç»Ÿè°ƒç”¨
2. é™·å…¥å†…æ ¸æ€ï¼Œä¿®æ”¹SPPä¸ºå½“å‰ç‰¹æƒçº§ï¼Œä¿å­˜ç³»ç»Ÿè°ƒç”¨ç»“æŸååº”è¯¥è¿”å›çš„åœ°å€
3. CPUè·³è½¬åˆ° trap å¤„ç†å…¥å£åœ°å€ï¼Œä¿®æ”¹å½“å‰ç‰¹æƒçº§åˆ«ä¸ºS
4. æ‰§è¡Œç³»ç»Ÿè°ƒç”¨
5. è¿”å›ç”¨æˆ·æ€

## CH3-å¤šé“ç¨‹åºè®¾è®¡

æ˜¾è€Œæ˜“è§ï¼Œå•é“æ‰¹å¤„ç†ç³»ç»Ÿæœ‰ä¸€ä¸ªå¼Šç«¯ï¼Œå½“ç¨‹åºéœ€è¦è®¿é—®å¤–è®¾æ—¶ï¼Œé‚£ä¹ˆCPUå°±è¦ç­‰å¾…è¯¥ç¨‹åºè®¿é—®å¤–è®¾çš„è¿™æ®µæ—¶é—´ï¼Œé€ æˆäº†CPUèµ„æºçš„æµªè´¹ï¼Œæˆ‘ä»¬å¸Œæœ›CPUèƒ½å¤Ÿä¸€ç›´å·¥ä½œã€‚é‚£ä¹ˆï¼Œåªè¦è®©CPUåœ¨ç­‰å¾…é˜¶æ®µè°ƒåº¦å…¶ä»–ç¨‹åºä¸ŠCPUå³å¯ï¼Œäºæ˜¯è®¾è®¡äº†æŠ¢å å¼è°ƒåº¦å’Œåä½œå¼è°ƒåº¦ã€‚

åœ¨åŸæ¥çš„æ‰¹å¤„ç†ç³»ç»Ÿï¼Œç¨‹åºè¢«åŠ è½½åˆ°äº†åŒä¸€ä¸ªåœ°å€ï¼Œæ‰€ä»¥å†…å­˜ä¸­åªèƒ½é©»ç•™ä¸€ä¸ªç¨‹åºï¼Œç°åœ¨æˆ‘ä»¬å¸Œæœ›å†…å­˜ä¸­èƒ½é©»ç•™å¤šä¸ªç¨‹åºï¼Œæ‰€ä»¥å¯ä»¥å°†ç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ä¸åŒçš„ä½ç½®ã€‚

æ•™ç¨‹ä¸­å®ç°äº†ä¸€ä¸ªè„šæœ¬ï¼Œä¸ºæ¯ä¸€ä¸ªåº”ç”¨ç¨‹åºå®šåˆ¶è‡ªå·±çš„é“¾æ¥è„šæœ¬ï¼Œå°†ç¨‹åºé“¾æ¥åˆ°ä¸åŒçš„åœ°å€ä¸Šï¼š

```python
import os

base_address = 0x80400000
step = 0x20000
linker = 'src/linker.ld'

app_id = 0
apps = os.listdir('src/bin')
apps.sort()
for app in apps:
    app = app[:app.find('.')]
    lines = []
    lines_before = []
    with open(linker, 'r') as f:
        for line in f.readlines():
            lines_before.append(line)
            line = line.replace(hex(base_address), hex(base_address+step*app_id))
            lines.append(line)
    with open(linker, 'w+') as f:
        f.writelines(lines)
    os.system('cargo build --bin %s --release' % app)
    print('[build.py] application %s start with address %s' %(app, hex(base_address+step*app_id)))
    with open(linker, 'w+') as f:
        f.writelines(lines_before)
    app_id = app_id + 1
```

é™¤æ­¤ä»¥å¤–ï¼Œè¿˜è¦å®ç°ä»»åŠ¡çš„åˆ‡æ¢ï¼Œè®©å ç”¨CPUçš„ç¨‹åºäº¤å‡ºCPUã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨æŠ¢å å¼è°ƒåº¦ä¸­ï¼Œç³»ç»Ÿå¯ä»¥é‡‡ç”¨æ—¶é—´ç‰‡è½®è½¬è°ƒåº¦ï¼Œå½“ä¸€ä¸ªä»»åŠ¡åœ¨CPUä¸Šè¿è¡Œä¸€ä¸ªæ—¶é—´ç‰‡ï¼Œç³»ç»Ÿä¼šå¼ºåˆ¶è®©åŸå…ˆçš„ä»»åŠ¡ä¸Šå‡ºCPUï¼Œæ–°çš„ä»»åŠ¡è¢«é€ä¸ŠCPUè¿è¡Œã€‚è¦çŸ¥é“ä¸€ä¸ªæ—¶é—´ç‰‡æ˜¯å¦è¿è¡Œå®Œæ¯•ï¼Œé çš„æ˜¯æ—¶é’Ÿä¸­æ–­ï¼Œè¯¥ä¸­æ–­ç”±ç¡¬ä»¶å‘å‡ºï¼Œå†…æ ¸ä¼šæ£€æµ‹åˆ°ä¸­æ–­å¹¶å¤„ç†ã€‚åŒæ ·çš„ï¼Œå¦‚æœæ˜¯åä½œå¼è°ƒåº¦ï¼Œåˆ™ç”±ä»»åŠ¡è‡ªè¡Œè®©å‡ºCPUï¼Œä¹Ÿæ˜¯å‘å‡ºä¸­æ–­ï¼Œå¤„ç†å‡½æ•°å¦‚ä¸‹ï¼š

```rust
#[no_mangle]
/// handle an interrupt, exception, or system call from user space
pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
	// ....
    match scause.cause() {
		// .....
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            set_next_trigger();
            suspend_current_and_run_next(); // åˆ‡æ¢ç¨‹åº
        }
		// .....
    }
    cx
}
```

æ£€æµ‹åˆ°ä¸­æ–­åï¼Œå°±ä¼šè¿è¡Œ `suspend_current_and_run_next()` åˆ‡æ¢åˆ°ä»»åŠ¡è¿è¡Œï¼Œç³»ç»Ÿå°†è°ƒç”¨è¿™æ®µä»£ç è¿›è¡Œä»»åŠ¡åˆ‡æ¢ï¼Œï¼š

```assembly
.altmacro
.macro SAVE_SN n
    sd s\n, (\n+2)*8(a0)
.endm
.macro LOAD_SN n
    ld s\n, (\n+2)*8(a1)
.endm
    .section .text
    .globl __switch
__switch:
    # __switch(
    #     current_task_cx_ptr: *mut TaskContext,
    #     next_task_cx_ptr: *const TaskContext
    # )
    # save kernel stack of current task
    sd sp, 8(a0)
    # save ra & s0~s11 of current execution
    sd ra, 0(a0)
    .set n, 0
    .rept 12
        SAVE_SN %n
        .set n, n + 1
    .endr
    # restore ra & s0~s11 of next execution
    ld ra, 0(a1)
    .set n, 0
    .rept 12
        LOAD_SN %n
        .set n, n + 1
    .endr
    # restore kernel stack of next task
    ld sp, 8(a1)
    ret
```

ä¸Šè¿°ä»£ç ä¸­ï¼Œä¿å­˜äº†ä»»åŠ¡çš„ä¸Šä¸‹æ–‡ï¼Œä¾¿äºä¸‹æ¬¡åˆ‡æ¢å›ä»»åŠ¡æ—¶è¿›è¡Œæ¢å¤ï¼Œä¸Šä¸‹æ–‡ç»“æ„å¦‚ä¸‹ï¼š

```rust
/// Task Context
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TaskContext {
    /// return address ( e.g. __restore ) of __switch ASM function
    ra: usize,
    /// kernel stack pointer of app
    sp: usize,
    /// callee saved registers:  s 0..11
    s: [usize; 12],
}
```

ä»»åŠ¡çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œä¿å­˜äº†è¿”å›åœ°å€ï¼Œå†…æ ¸æ ˆçš„æ ˆé¡¶å’Œè°ƒç”¨å¯„å­˜å™¨ç»„ã€‚

å½“ç³»ç»Ÿå¯åŠ¨ï¼Œåˆ™å¯åŠ¨ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼š

```rust
fn run_first_task(&self) -> ! {
    let mut inner = self.inner.exclusive_access();
    let task0 = &mut inner.tasks[0];
    task0.task_status = TaskStatus::Running; // è®¾ç½®è¿è¡Œæ€
    let next_task_cx_ptr = &task0.task_cx as *const TaskContext;
    drop(inner);
    let mut _unused = TaskContext::zero_init();
    // before this, we should drop local variables that must be dropped manually
    unsafe {
        // åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªä»»åŠ¡
        __switch(&mut _unused as *mut TaskContext, next_task_cx_ptr);
    }
    panic!("unreachable in run_first_task!");
}
```

åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡è¿è¡Œï¼š

```rust
fn run_next_task(&self) {
    if let Some(next) = self.find_next_task() {
        let mut inner = self.inner.exclusive_access();
        let current = inner.current_task;
        inner.tasks[next].task_status = TaskStatus::Running;
        inner.current_task = next;
        let current_task_cx_ptr = &mut inner.tasks[current].task_cx as *mut TaskContext;
        let next_task_cx_ptr = &inner.tasks[next].task_cx as *const TaskContext;
        drop(inner);
        // before this, we should drop local variables that must be dropped manually
        unsafe {
            __switch(current_task_cx_ptr, next_task_cx_ptr);
        }
        // go back to user mode
    } else {
        println!("All applications completed!");
        shutdown(false);
    }
}
```

åˆ°æ­¤ä¾¿å®ç°äº†ä»»åŠ¡åˆ‡æ¢